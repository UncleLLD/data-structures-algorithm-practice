### 题目
来源：力扣（LeetCode）
链接：[https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii](https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii)


我们正在玩一个猜数游戏，游戏规则如下：

我从 1 到 n 之间选择一个数字。
你来猜我选了哪个数字。
如果你猜到正确的数字，就会 赢得游戏 。
如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。
每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。
给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字 。


**示例 1：**
>输入：n = 10
>输出：16
>解释：制胜策略如下：
>- 数字范围是 [1,10] 。你先猜测数字为 7 。
>   - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $7 。
>   - 如果我的数字更大，则下一步需要猜测的数字范围是 [8,10] 。你可以猜测数字为 9 。
>       - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $9 。
>       - 如果我的数字更大，那么这个数字一定是 10 。你猜测数字为 10 并赢得游戏，总费用为 $7 + $9 = $16 。
>       - 如果我的数字更小，那么这个数字一定是 8 。你猜测数字为 8 并赢得游戏，总费用为 $7 + $9 = $16 。
>   - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,6] 。你可以猜测数字为 3 。
>       - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $3 。
>       - 如果我的数字更大，则下一步需要猜测的数字范围是 [4,6] 。你可以猜测数字为 5 。
>           - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $5 。
>           - 如果我的数字更大，那么这个数字一定是 6 。你猜测数字为 6 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。
>           - 如果我的数字更小，那么这个数字一定是 4 。你猜测数字为 4 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。
>       - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,2] 。你可以猜测数字为 1 。
>           - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $1 。
>           - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $7 + $3 + $1 = $11 。
>           在最糟糕的情况下，你需要支付 $16 。因此，你只需要 $16 就可以确保自己赢得游戏。


**示例 2：**
>输入：n = 1
>输出：0
>解释：只有一个可能的数字，所以你可以直接猜 1 并赢得游戏，无需支付任何费用。

**示例 3：**
>输入：n = 2
>输出：1
>解释：有两个可能的数字 1 和 2 。
>- 你可以先猜 1 。
>   - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $1 。
>  - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $1 。
>   最糟糕的情况下，你需要支付 $1 。


**提示：**
>1 <= n <= 200

 

### 解法
* 动态规划法： 这题乍一看是类似于二分查找的过程，但是无法判断选取的那个数是否是要的那个数，且代价依赖于该数。这种情况一般需要存储不同状态下的代价，因此考虑使用动态规划或者递归的方式做，本节参考答案采用动态规划的方法做。`dp[i][j]`表示i~j的最小代价。那么假设x是i与j之间的某个值，下面存在三种状态：
	- x是要找到值，则代价为上一次猜测的代价+代价0
	- x要比猜的值要大，则代价为上一次 猜测的代价+x，并且下一次猜测只能在i~x-1中进行猜测
	- x要比猜测的值要小，则代价为上一次猜测的代价+x，并且下一次猜测只能在x+1~j中进行猜测 
	- 由于要求最小的代价，则可以有状态转移式子:$dp[i][j] = min(dp[i][j], x+max(dp[i][x-1], dp[x+1][j])$

* python
```python
class Solution:
    def getMoneyAmount(self, n: int) -> int:
        dp = [[0]*(n+1) for _ in range(n+1)]
        for i in range(n-1, 0, -1):
            for j in range(i+1, n+1):
                dp[i][j] = j + dp[i][j-1]
                for k in range(i, j):
                    dp[i][j] = min(dp[i][j], k+max(dp[i][k-1], dp[k+1][j]))
        return dp[1][n]
```
* c++

```c++
class Solution {
public:
    int getMoneyAmount(int n) {
        vector<vector<int>> dp(n+1, vector<int>(n+1));
        for(int i=n-1; i>0; i--)
        {
            for(int j=i+1; j<=n; j++)
            {
                dp[i][j] = j + dp[i][j-1];
                for(int k=i+1; k<j; k++)
                {
                    dp[i][j] = min(dp[i][j], k+max(dp[i][k-1], dp[k+1][j]));
                }
            }
        }
        return dp[1][n];

    }
};
```

>注意：
>逆序遍历是为了减少计算量。举个例子： 如果要计算dp[1][n] 那么需要dp[1][k - 1], dp[k + 1][n]已经计算。而在正向的遍历中，dp[k + 1][n]此时还没有得到计算


#### 复杂度分析
* 时间复杂度： 
	*  $O(n^3)$
* 空间复杂度： 
	*  $O(n^2)$


#### 参考
* [https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/solution/cai-shu-zi-da-xiao-ii-by-leetcode-soluti-a7vg/](https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/solution/cai-shu-zi-da-xiao-ii-by-leetcode-soluti-a7vg/)