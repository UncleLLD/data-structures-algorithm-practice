### 91. 解码方法
来源：力扣（LeetCode）

链接: [https://leetcode.cn/problems/decode-ways/](https://leetcode.cn/problems/decode-ways/)

一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：
```
'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
```

要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：
* "AAJF" ，将消息分组为 (1 1 10 6)
* "KJF" ，将消息分组为 (11 10 6)

注意，消息不能分组为  `(1 11 06) `，因为 `"06"` 不能映射为 `"F"` ，这是由于 "6" 和 "06" 在映射中并不等价。

给你一个只含数字的 非空 字符串 s ，请计算并返回 **解码** 方法的 **总数** 。

题目数据保证答案肯定是一个 **32 位 的整数**。

 

**示例 1：**
```
输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
```

**示例 2：**
```
输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```

**示例 3：**
```
输入：s = "0"
输出：0
解释：没有字符映射到以 0 开头的数字。
含有 0 的有效映射是 'J' -> "10" 和 'T'-> "20" 。
由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。
```

**提示：**
* 1 <= s.length <= 100
* s 只包含数字，并且可能包含前导零。

### 解法
* 动态规划：字符串组合前后相关联的话，可以考虑使用递归或者动态规划的方法，由于递归复杂度且重复性计算过多，这里介绍动态规划的方法。
	**动态规划：四个步骤：**
	- **问题定义**
	- **状态转移方程**
	- **初始条件和边界情况**
	- **确定计算顺序（自顶向下，还是自下向上）**

**问题定义：**
dp[i] 表示下标到达i处时候的解码总数

**状态转移方程：**
考虑单个字符，以及与前面一个字符组合成两个字符的情况
* 考虑单个字符，当s[i] 不等于'0'时候，s[i]为'1'~'9'， 肯定能被解码，此时dp[i] = dp[i-1]， 因为固定了
* 考虑与前面字符组合情况，当s[i-1] 等于'0'时候，两位数无法解码，只有当s[i-1] 不等于'0'时候才有解码，又需要满足26个字母大小要求，两位数组合应该小于等于26,此时dp[i] += dp[i-2], 由于出现了`i-2`，需要对i的大小边界进行判断：
	* 如果i > 1, dp[i] += dp[i-2],
	* 如果i == 1, 只有一种表达方式，dp[i] += 1

**初始化条件和边界条件**
* dp[0] = 1


**确定计算顺序**:
这个是从下向上的方向计算即可

### 代码实现
#### 动态规划
**python实现**
```python
class Solution:
    def numDecodings(self, s: str) -> int:
        n = len(s)
        if s[0] == '0':
            return 0
        
        dp = [0] * n 
        dp[0] = 1
        for i in range(1, n):
            if s[i] != '0':
                dp[i] = dp[i-1]
            
            if s[i-1] != '0' and int(s[i-1:i+1]) <= 26:
                if i > 1:
                    dp[i] += dp[i-2]
                if i == 1:
                    dp[i] += 1
        return dp[-1]
```


**c++实现**
```cpp
class Solution {
public:
    int numDecodings(string s) {
        int n = s.size();
        if (s[0] == '0') return 0;

        vector<int> dp (n, 0);
        dp[0] = 1;
        for (int i=1; i<n; i++) {
            if (s[i] != '0') dp[i] = dp[i-1];

            if (s[i-1] != '0' && ((s[i-1]-'0')*10 + (s[i]-'0')) <= 26){
                if (i > 1) dp[i] += dp[i-2];
                else dp[i] += 1;
            }
        }
        return dp[n-1];
    }
};
```


**复杂度分析**
* 时间复杂度： $O(n )$ 
* 空间复杂度： $O(n)$

### 参考
* [https://leetcode.cn/problems/decode-ways/solution/jie-ma-fang-fa-by-leetcode-solution-p8np/](https://leetcode.cn/problems/decode-ways/solution/jie-ma-fang-fa-by-leetcode-solution-p8np/)