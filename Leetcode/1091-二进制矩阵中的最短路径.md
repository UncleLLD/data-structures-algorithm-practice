### 1091. 二进制矩阵中的最短路径
来源：力扣（LeetCode）

链接: [https://leetcode.cn/problems/shortest-path-in-binary-matrix/description/](https://leetcode.cn/problems/shortest-path-in-binary-matrix/description/)

给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 **畅通路径** 的长度。如果不存在这样的路径，返回 -1 。

二进制矩阵中的 **畅通路径** 是一条从 **左上角** 单元格（即，(0, 0)）到 **右下角** 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求：
* 路径途经的所有单元格都的值都是 0 。
* 路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。
* 畅通路径的长度 是该路径途经的单元格总数。

**示例 1：**
![在这里插入图片描述](https://img-blog.csdnimg.cn/4833dc6f6bca4c8eaaf2395548ca3c9a.png)
> 输入：grid = [[0,1],[1,0]]
> 输出：2

**示例 2：**
![在这里插入图片描述](https://img-blog.csdnimg.cn/e037e89189ab4bf4a8acd966e439f2f4.png)

> 输入：grid = [[0,0,0],[1,1,0],[1,1,0]]
> 输出：4

**示例 3：**

> 输入：grid = [[1,0,0],[1,1,0],[1,1,0]]
> 输出：-1


**提示：**
* n == grid.length
* n == grid[i].length
* 1 <= n <= 100
* grid[i][j] 为 0 或 1

### 解法
* BFS: 从起点开始启动，按照八个方向进行发散，如果能够往下走，距离加一；如果遍历到右下角，且右下角不为1，则完成；

### 代码实现
#### BFS
**python实现**
```python
class Solution:
    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:
        n = len(grid)
        queue = [(0, 0, 1)]
        if grid[0][0] == 1 or grid[-1][-1] == 1:
            return -1
        if n <= 2:
            return n
        
        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
        
        while queue:
            i, j, d = queue.pop(0)
            for di, dj in dirs:
                ni = i + di
                nj = j + dj
                if 0 <= ni < n and 0 <= nj < n and not grid[ni][nj]:
                    if ni == n-1 and nj == n-1:
                        return d + 1
                    queue.append((ni, nj, d+1))
                    grid[ni][nj] = 1  # 已访问
        return -1
```


**c++实现**
```cpp
class Solution {
public:
    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
        int n = grid.size();
        queue<vector<int>> q;
        q.push({0, 0, 1});
        if (grid[0][0] == 1 || grid[n-1][n-1] == 1) return -1;
        else if (n <= 2) return n;

        int dirs[8][2] =  {{-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}, {-1, -1}};

        while(!q.empty()) {
            vector<int> start = q.front();
            int i = start[0];
            int j = start[1];
            int d = start[2];
            q.pop();
            for (auto dir: dirs) {
                int ni = i + dir[0];
                int nj = j + dir[1];
                if (ni >= 0 && ni < n && nj >= 0 && nj < n && grid[ni][nj]==0){
                    if (ni == n-1 && nj == n-1) return d+1;
                    q.push({ni, nj, d+1});
                    grid[ni][nj] = 1;  // 已访问
                }
            }
        }
        return -1;
    }
};
```

**复杂度分析**
* 时间复杂度： $O(n^2)$ 
* 空间复杂度： $O(n^2)$  